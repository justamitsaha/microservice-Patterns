# =========================================
# ? Service Identity
# =========================================
# Unique name of this service - used for discovery registration and to fetch configuration from the Config Server.
spring.application.name=${SPRING_APP_NAME:gateway-service}

#Can be overridden from Env variables with value confluent to load confluent based kafka properties from application-confluent.properties
spring.profiles.active=${SPRING_PROFILES_ACTIVE:default}

# =========================================
# ?? Configuration Source
# =========================================
# URL of the Spring Cloud Config Server. 'optional:' ensures that the application can still start
# even if the Config Server is temporarily unreachable.
spring.config.import=${SPRING_CONFIG_IMPORT:optional:configserver:http://localhost:8888}

# =========================================
# ? Server Port
# =========================================
# Local port on which the Gateway service will run.
# Keep this here (not in Config Server) so it can start independently.
server.port=${SERVER_PORT:8085}

# =========================================
# ?? Eureka Client Configuration
# =========================================
# URL of the Eureka Discovery Server - tells Gateway where to register itself.
# In a real environment, replace localhost with the Eureka server's actual host/IP.
eureka.client.service-url.defaultZone=${EUREKA_DEFAULT_ZONE:http://localhost:8761/eureka}

# Prefer IP address instead of hostname when registering with Eureka.
# Useful in Docker, Kubernetes, or mixed-host environments.
eureka.instance.prefer-ip-address=${EUREKA_PREFER_IP:true}

# =========================================
# ? Kafka Configuration (for Spring Cloud Bus)
# =========================================
spring.cloud.stream.kafka.binder.brokers=${SPRING_CLOUD_STREAM_KAFKA_BROKERS:localhost:9092,localhost:9093,localhost:9094}

# =========================================
# ? Spring Cloud Bus (Kafka Integration)
# =========================================
spring.cloud.bus.enabled=${SPRING_CLOUD_BUS_ENABLED:true}
spring.cloud.bus.refresh.enabled=${SPRING_CLOUD_BUS_REFRESH_ENABLED:true}

# Kafka Bus Topic
#spring.cloud.stream.bindings.springCloudBusOutput.destination=${SPRING_CLOUD_BUS_TOPIC:config-bus-topic}
#spring.cloud.stream.bindings.springCloudBusInput.destination=${SPRING_CLOUD_BUS_TOPIC:config-bus-topic}

# =========================================
# ? Logging Configuration
# =========================================
logging.pattern.console=${LOG_PATTERN_CONSOLE:%green(%d{HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) traceId=%X{traceId:-} spanId=%X{spanId:-} %yellow(%class.%M:%L) - %msg%n}



# =========================================
# ?? Actuator & Management Endpoints
# =========================================
# Exposes key endpoints for:
#   - health:      Application health
#   - info:        Build/version info
#   - metrics:     System performance metrics
#   - prometheus:  Prometheus scrape endpoint for Grafana dashboards
#   - refresh:     Manual refresh of configuration
#   - busrefresh:  Broadcast refresh events via Spring Cloud Bus
# 1. Expose the specific endpoints (including circuitbreakers)
management.endpoints.web.exposure.include=health,info,metrics,circuitbreakers,circuitbreakerevents

# 2. Enable the circuit breaker health indicator
management.health.circuitbreakers.enabled=true

# 3. CRITICAL: Register the specific breaker with the health system
# Replace 'customersCb' with your actual circuit breaker name if different
resilience4j.circuitbreaker.instances.customersCb.registerHealthIndicator=true

# 4. Optional: Show full details in the health endpoint
management.endpoint.health.show-details=always


# --- Circuit Breaker: customersCb ---
# Calculation starts after 10 calls (prevents early tripping)
resilience4j.circuitbreaker.instances.customersCb.minimumNumberOfCalls=10
# How many calls to remember for the failure rate
resilience4j.circuitbreaker.instances.customersCb.slidingWindowSize=20
# If 50% of the last 20 calls fail, OPEN the circuit
resilience4j.circuitbreaker.instances.customersCb.failureRateThreshold=50
# Give the service 30 seconds to recover before trying again
resilience4j.circuitbreaker.instances.customersCb.waitDurationInOpenState=30s
# In HALF_OPEN state, allow 5 "probe" calls to see if it's fixed
resilience4j.circuitbreaker.instances.customersCb.permittedNumberOfCallsInHalfOpenState=5


# =========================================
# ? Distributed Tracing (OpenTelemetry)
# =========================================
# Probability of sampling traces.
# Set to 1.0 for full tracing in development; reduce in production (e.g., 0.1).
#management.tracing.sampling.probability=${TRACING_SAMPLING:1.0}

# Endpoint for the OpenTelemetry Collector (OTLP)
# which receives and forwards trace spans to observability backends
# such as Grafana Tempo, Jaeger, or OpenSearch.
#management.otlp.tracing.endpoint=${OTLP_ENDPOINT:http://localhost:4318/v1/traces}


spring.reactor.context-propagation=auto
