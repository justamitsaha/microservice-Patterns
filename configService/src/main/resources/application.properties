# =========================================
# ?? Core Server & Application Info
# =========================================
# Logical name of this service.
# Other microservices use this name (config-service) to fetch their configurations
# from the Config Server via: spring.config.import=optional:configserver:http://localhost:8888
spring.application.name=${SPRING_APP_NAME:config-service}
spring.config.import=${SPRING_CONFIG_IMPORT:}
# Port on which the Config Server runs.
# This must stay local so that the server can start before fetching any remote configuration.
server.port=${SERVER_PORT:8888}

# =========================================
# ?? Git Configuration Repository
# =========================================
# The remote Git repository containing all configuration files for your microservices.
# Each service (gateway-service, discovery-service, customer-service, etc.)
# will have its own {service-name}.properties or {service-name}.yml file inside this repo.
# ?? Important: This section MUST remain local ? the Config Server cannot fetch its own repo details from itself.
spring.cloud.config.server.git.uri=${CONFIG_GIT_URI:https://github.com/justamitsaha/configurationServer.git}
spring.cloud.config.server.git.timeout=${CONFIG_GIT_TIMEOUT:5}
spring.cloud.config.server.git.force-pull=${CONFIG_GIT_FORCE_PULL:true}
spring.cloud.config.server.git.clone-on-start=${CONFIG_GIT_CLONE_ON_START:true}
spring.cloud.config.server.git.default-label=${CONFIG_GIT_BRANCH:main}
#Don?t try to fetch your own config from yourself
spring.cloud.config.enabled=${CONFIG_SERVER_ENABLED:false}

# =========================================
# ? Local Fallback Profile (Native Mode)
# =========================================
# Enables the 'native' profile, allowing the Config Server to read configs directly from the classpath.
# This is useful during local development or when Git is temporarily unavailable.
#spring.profiles.active=native

# Directory where local configuration files are stored when using native mode.
# The Config Server will search inside this folder for service configuration files.
#spring.cloud.config.server.native.searchLocations=classpath:/config

# =========================================
# ? Spring Cloud Bus (Kafka Integration)
# =========================================
# Enables Spring Cloud Bus, which propagates configuration refresh events across all
# microservices connected to the Config Server using Kafka as the transport layer.
spring.cloud.bus.enabled=${SPRING_CLOUD_BUS_ENABLED:true}

# Ensures that refresh events (e.g., triggered by /actuator/busrefresh)
# are automatically handled and distributed across the system.
spring.cloud.bus.refresh.enabled=${SPRING_CLOUD_BUS_REFRESH_ENABLED:true}

# =========================================
# ? Kafka Topics for Config Refresh Events
# =========================================
# Defines the Kafka topic used to broadcast configuration change events.
# Both input and output bindings use the same topic for simplicity.
spring.cloud.stream.bindings.springCloudBusOutput.destination=${SPRING_CLOUD_BUS_TOPIC:config-bus-topic}
spring.cloud.stream.bindings.springCloudBusInput.destination=${SPRING_CLOUD_BUS_TOPIC:config-bus-topic}

# ? How It Works:
# - When you POST to /actuator/busrefresh on the Config Server,
#   it publishes a "RefreshRemoteApplicationEvent" to this Kafka topic.
# - All other microservices connected to the same topic receive the event
#   and automatically refresh their configuration via /actuator/refresh.


# =========================================
# ? Kafka Broker Connection (for Spring Cloud Bus)
# =========================================
# Comma-separated list of Kafka brokers forming the cluster.
# These brokers handle Spring Cloud Bus messages (config refresh broadcasts).
spring.cloud.stream.kafka.binder.brokers=${SPRING_CLOUD_STREAM_KAFKA_BROKERS:localhost:9092,localhost:9093,localhost:9094}

# Uncomment the following line for local development environments.
# This allows Kafka to automatically create topics (like config-bus-topic) if they don?t already exist.
# spring.cloud.stream.kafka.binder.auto-create-topics=true

# ? Topic Creation Details:
# - In most local setups, Kafka auto-creates topics on first publish.
# - In production, if `auto.create.topics.enable=false`, create manually using:
#   kafka-topics.sh --create --topic config-bus-topic --partitions 3 --replication-factor 1 --bootstrap-server localhost:9092


# =========================================
# ?? Management & Actuator Configuration
# =========================================
# Exposes operational endpoints for monitoring and management.
# - health:       Shows service health
# - info:         Shows build and metadata
# - refresh:      Manually reloads configuration
# - busrefresh:   Broadcasts refresh events across all connected services
management.endpoints.web.exposure.include=${MANAGEMENT_ENDPOINTS:busrefresh,refresh,health,info}

# =========================================
# ? Kafka Observability (Micrometer Integration)
# =========================================
# Enables Micrometer to expose Kafka client metrics via Actuator endpoints.
# This is separate from Spring Cloud Bus messaging itself.
# Useful for monitoring producer/consumer latency, lag, and record throughput.
management.kafka.bootstrap-servers=${MANAGEMENT_KAFKA_BOOTSTRAP:localhost:9092,localhost:9093,localhost:9094}

# Show detailed component health info (e.g., Kafka, Git repo, Bus status)
management.endpoint.health.show-details=always

# =========================================
# ? Distributed Tracing (OpenTelemetry)
# =========================================
# Sampling probability for distributed tracing.
# 1.0 = trace every request (recommended for development)
# Use lower values in production (e.g., 0.1 = 10% sampling).
management.tracing.sampling.probability=${TRACING_SAMPLING:1.0}

# OTLP endpoint where the Config Server exports trace spans. Does not use topic
# This collector (e.g., OpenTelemetry Collector, Grafana Agent, or Jaeger) processes tracing data.
management.otlp.tracing.endpoint=${OTLP_ENDPOINT:http://localhost:4318/v1/traces}

# Logging
logging.pattern.console=${LOG_PATTERN:%green(%d{HH:mm:ss.SSS}) %blue(%-5level) %red([%thread]) %yellow(%class.%M:%L) - %msg%n}
logging.level.root=${LOG_LEVEL_ROOT:INFO}
logging.level.org.springframework.boot=${LOG_LEVEL_SPRING_BOOT:INFO}
logging.level.org.springframework.cloud=${LOG_LEVEL_SPRING_CLOUD:WARN}
logging.level.org.apache.kafka=${LOG_LEVEL_KAFKA:WARN}
logging.level.org.springframework.integration=${LOG_LEVEL_SI:WARN}
logging.level.io.opentelemetry=${LOG_LEVEL_OTEL:ERROR}

encrypt.key=${ENCRYPT_KEY:45D81EC1EF61DF9AD8D3E5BB397F9}
